[ 스프링 스큐리티 ]
    1. 정의
        : spring 기반의 인증과 인가를 제공하는 라이브러리
    2. 대표기능
        : 로그인, 로그아웃, 소셜로그인, CSRF 공격 방지, HTTP 요청 방지
    3. 사용법
        1) 설치 gradle
            ```
            implementation 'org.springframework.boot:spring-boot-starter-security'
            ```
            ※ 설치와 동시에 기본 필터가 작동됨
        2) 시큐리티 커스텀 (version 및 상황에 따라 커스텀 방법이 다양_강의는 Spring 3.0 기준)

            ```java
            @Configuration
            @RequiredArgsConstructor
            public class SecurityConfig {
                /*
                * 시큐리티(보안) 필터(검증/확인) 체인(연결고리)
                * - 미리 만들어저 있는 필터가 다수임
                * - 따라서 필요없는 필터에 대한 종료 필요
                */

                // [1] 개발자가 만든 토큰을 세큐리티 토큰에 통합한 class
                private final JwtAuthFilter jwtAuthFilter;

                /**
                 * [2] HTTP 관련 필터에 대한 커스텀
                 */
                @Bean
                public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {

                    // [2.1] HTTP 요청에 따른 권한 커스텀 **********************************
                    // .authorizeHttpRequests( auth -> auth.requestMatchers("경로").권한
                    // "/**" 모든 경로
                    // .permitAll() : 모두 허가
                    // .hasRole("권한") : 해당 권한만 가능
                    // .hasAnyRole("권한", "권한") : 복수 권한
                    // 참고 : 권한명은 대문자를 권고
                    http.authorizeHttpRequests( auth -> auth
                            .requestMatchers("/api/user/info").hasAnyRole("ADMIN", "USER")
                            .requestMatchers("/api/admin/**").hasRole("ADMIN") //해당 api는 ADMIN 권한만 사용 가능
                            .requestMatchers("/**").permitAll() );  // 모든 권한 허용은 최하단에 정의

                    // [2.2] HTTP 요청 중 SCRF (요청 간의 해킹 공격) => POST / PUT이 차단됨 **********************************
                    // http.csrf( csrf -> csrf.ignoringResuestMatchers("csrf제외경로"); // 운영단계 권장
                    http.csrf(csrf -> csrf.disable() ); // 개발단계에서 권장 //csrf를 사용하지 않음

                    // [2.3] security 내부에서 사용되는 세션기반 토큰 **********************************
                    // UsernamePasswordAuthenticationToken
                    // 현재 web2에서는 쿠키 기반의 토큰을 구현
                    // >> 시큐리티 내부 토큰은 사용하지 않음
                    // [2.3-1] 시큐리티 세션 끄기
                    http.sessionManagement(
                            session
                                    -> session.sessionCreationPolicy( SessionCreationPolicy.STATELESS) );
                    // [2.3-2] 개발자가 만든 토큰 대체
                    // http.addFilterBefore( 내가만든토큰객체필터, UsernamePasswordAuthenticationToken.class )
                    http.addFilterBefore( jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);

                    return http.build(); // 커스텀 완료 객체
                } // func end

            } // class end

            ```

            class 어노테이션에 권한을 부여하는 방법도 있음
            ```
            // controller 에서

            @PreAuthorize("admin")
            public ~~
            ```

        3) 개발자가 만든 토큰의 인증 방법을
           시큐리티 방식인 UsernamePasswordAuthenticationToken 과 통합
           ```java
           @Component
           @RequiredArgsConstructor
           public class JwtAuthFilter extends OncePerRequestFilter {

               /**
                * [1] 개발자가 만든 토큰 방식
                */
               private final JwtService jwtService;

               /**
                * [2] 기존 시큐리티 방식의 필터 커스텀 ***********************************
                * extends OncePerRequestFilter
                * doFilterInternal 오버라이딩
                */
               @Override
               protected void doFilterInternal(HttpServletRequest request,
                                               HttpServletResponse response,
                                               FilterChain filterChain) throws ServletException, IOException {
                   // [2.1] 쿠키에서 토큰 추출
                   String token = null;
                   if (request.getCookies() != null) {    // 쿠키가 존재하면
                       for (Cookie cookie : request.getCookies()) {
                           if (cookie.getName().equals("loginUser")) { // 로그인한 쿠키가 존재하면
                               token = cookie.getValue();               // 쿠키값 꺼내기
                           }
                       }
                   }

                   // [2.2] UsernamePasswordAuthenticationToken 재정의
                   if(token != null && jwtService.checkToken(token)){ // 토큰이 유효하면
                       // [2.2.1] 아이디 꺼내기
                       String uid = jwtService.getUid(token);
                       // [2.2.1] 권한 꺼내기
                       String urole = jwtService.getUrole(token);

                       // [2.2.2] 시큐리티가 원하는 토큰 만들기 = UsernamePasswordAuthenticationToken
                       // new UsernamePasswordAuthenticationToken( "id", "password", "role" );
                       // 복수 권한 부여시 role 자리에 : List.of( new SimpleGrantedAuthority("ROLE_XXX"), new SimpleGrantedAuthority("ROLE_XXX"), ... )
                       UsernamePasswordAuthenticationToken authToken =
                               new UsernamePasswordAuthenticationToken(uid , null ,
                                       List.of( new SimpleGrantedAuthority("ROLE_"+urole) ));

                       // [2.2.3] 시큐리티가 사용할 수 있도록 토큰을 저장
                       // SecurityContext
                       SecurityContextHolder.getContext().setAuthentication(authToken);
                   }

                   // [3] 다른 필터에서 해당하는 토큰필터를 호출할 수 있도록 함
                   filterChain.doFilter( request, response ) ;

               } // func end
           } // class end

           ```